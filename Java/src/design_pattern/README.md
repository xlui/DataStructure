# 设计模式

## 什么是设计模式

设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现在都有相应的原理与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。

## 目录

![Design Patterns](../../../Images/designPatterns.png)

创建型模式：

1. [单例模式](#单例模式)
1. [工厂方法模式](#工厂方法模式)
1. [抽象工厂模式](#抽象工厂模式)
1. [建造者模式](#建造者模式)
1. [原型模式](#原型模式)

结构型模式：

1. [适配器模式](#适配器模式)
1. [桥接模式](#桥接模式)
1. [组合模式](#组合模式)
1. [装饰器模式](#装饰器模式)
1. [外观模式](#外观模式)
1. [享元模式](#享元模式)
1. [代理模式](#代理模式)

行为型模式：

1. [访问者模式](#访问者模式)
1. [模板模式](#模板模式)
1. [策略模式](#策略模式)
1. [状态模式](#状态模式)
1. [观察者模式](#观察者模式)
1. [备忘录模式](#备忘录模式)
1. [中介者模式](#中介者模式)
1. [迭代器模式](#迭代器模式)
1. [解释器模式](#解释器模式)
1. [命令模式](#命令模式)
1. [责任链模式](#责任链模式)

总结：

1. [总结](#总结)

## 单例模式

单例模式保证了一个类只有一个实例，并提供一个访问它的全局访问点。

**何时使用：**

想控制实例数目，节省系统资源

**应用实例：**

1. 一个党只能有一个主席
1. Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行
1. 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件

**优点：**

1. 在内存里只有一个实例，减少了内存开销，尤其是频繁的创建和销毁实例
1. 避免对资源的多重占用

**缺点：**

没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化

## 工厂方法模式

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。

**何时使用：**

我们明确地计划不同条件下创建不同实例时

**应用示例：**

1. 您需要一辆汽车，可以直接从工厂里面提货，而不用去管汽车是怎么做出来的，以及这个汽车里面的具体实现
1. Hibernate 换数据库只需要换方言和驱动就可以

**优点：**

1. 一个调用者想创建一个对象，只需要知道其名称就可以了
1. 扩展性高，如果想增加一个产品，只需要扩展一个工厂类就可以
1. 屏蔽产品的具体实现，调用者只关心产品的接口

**缺点：**

1. 每次增加一个产品时，都需要增加一个具体的类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖

## 抽象工厂模式

抽象工厂模式提供了一个创建一系列相关或者互相依赖的对象的接口，而无需指定它们具体的类。

**何时使用：**

系统的产品有多于一个的产品族，而系统只消费其中某一族的产品

**应用实例：**

工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

**优点：**

当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象

**缺点：**

产品族扩展十分困难，要增加一个一个系列的某一个产品，既要在抽象的 Creator 里加代码，也要在具体的实现里加代码

## 建造者模式

将一个复杂的构建过程与其表示相分离，使得同样的构建过程可以构建不同的表示。

**何时使用：**

一些基本部件不会变，而其组合经常变化的时候

**应用实例：**

1. 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的
1. Java 中的 StringBuilder

**优点：**

1. 建造者独立，易于扩展
1. 便于控制细节风险

**缺点：**

1. 产品必须有共同点，范围有限制
1. 如内部变化复杂，会有很多的建造类

## 原型模式
## 适配器模式
## 桥接模式
## 组合模式
## 装饰器模式
## 外观模式
## 享元模式
## 代理模式
## 访问者模式
## 模板模式
## 策略模式
## 状态模式
## 观察者模式
## 备忘录模式
## 中介者模式
## 迭代器模式
## 解释器模式
## 命令模式
## 责任链模式

## 总结
