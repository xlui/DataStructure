# 设计模式

## 什么是设计模式

设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现在都有相应的原理与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。

## 目录

![Design Patterns](../../../Images/designPatterns.png)

创建型模式：

1. [单例模式](#单例模式)
1. [工厂方法模式](#工厂方法模式)
1. [抽象工厂模式](#抽象工厂模式)
1. [建造者模式](#建造者模式)
1. [原型模式](#原型模式)

结构型模式：

1. [适配器模式](#适配器模式)
1. [桥接模式](#桥接模式)
1. [组合模式](#组合模式)
1. [装饰器模式](#装饰器模式)
1. [外观模式](#外观模式)
1. [享元模式](#享元模式)
1. [代理模式](#代理模式)

行为型模式：

1. [访问者模式](#访问者模式)
1. [模板模式](#模板模式)
1. [策略模式](#策略模式)
1. [状态模式](#状态模式)
1. [观察者模式](#观察者模式)
1. [备忘录模式](#备忘录模式)
1. [中介者模式](#中介者模式)
1. [迭代器模式](#迭代器模式)
1. [解释器模式](#解释器模式)
1. [命令模式](#命令模式)
1. [责任链模式](#责任链模式)

总结：

1. [总结](#总结)

## 单例模式

单例模式保证了一个类只有一个实例，并提供一个访问它的全局访问点。

**何时使用：**

想控制实例数目，节省系统资源

**应用实例：**

1. 一个党只能有一个主席
1. Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行
1. 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件

**优点：**

1. 在内存里只有一个实例，减少了内存开销，尤其是频繁的创建和销毁实例
1. 避免对资源的多重占用

**缺点：**

没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化

## 工厂方法模式

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。

**何时使用：**

我们明确地计划不同条件下创建不同实例时

**应用示例：**

1. 您需要一辆汽车，可以直接从工厂里面提货，而不用去管汽车是怎么做出来的，以及这个汽车里面的具体实现
1. Hibernate 换数据库只需要换方言和驱动就可以

**优点：**

1. 一个调用者想创建一个对象，只需要知道其名称就可以了
1. 扩展性高，如果想增加一个产品，只需要扩展一个工厂类就可以
1. 屏蔽产品的具体实现，调用者只关心产品的接口

**缺点：**

1. 每次增加一个产品时，都需要增加一个具体的类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖

## 抽象工厂模式

抽象工厂模式提供了一个创建一系列相关或者互相依赖的对象的接口，而无需指定它们具体的类。

**何时使用：**

系统的产品有多于一个的产品族，而系统只消费其中某一族的产品

**应用实例：**

工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

**优点：**

当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象

**缺点：**

产品族扩展十分困难，要增加一个一个系列的某一个产品，既要在抽象的 Creator 里加代码，也要在具体的实现里加代码

## 建造者模式

将一个复杂的构建过程与其表示相分离，使得同样的构建过程可以构建不同的表示。

**何时使用：**

一些基本部件不会变，而其组合经常变化的时候

**应用实例：**

1. 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的
1. Java 中的 StringBuilder

**优点：**

1. 建造者独立，易于扩展
1. 便于控制细节风险

**缺点：**

1. 产品必须有共同点，范围有限制
1. 如内部变化复杂，会有很多的建造类

## 原型模式

在我们应用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

**何时使用：**

1. 当一个系统应该独立于它的产品创建、构成和表示时
1. 当要实例化的类是在运行时刻指定时，例如，通过动态装载
1. 为了避免创建一个与产品类层次平行的工厂类层次时
1. 当一个类的实例只能有几个不同状态组合中的一种时，建立相应的原型并克隆他们可能比每次用合适的状态手工实例化该类更方便

**应用实例：**

1. 细胞分裂
1. Java 中的 `Object.clone()` 方法

**优点：**

1. 性能提高
1. 逃避构造函数的约束

**缺点：**

1. 配备克隆方法需要对类的功能进行通盘考虑，这对全新的类不是很难，但对已有的类不一定很容易，特别当一个类引用不支持串行化的简介对象，或者引用含有循环结构的时候
1. 必须实现 Cloneable 接口

## 适配器模式

在我们的应用程序中我们可能**需要将两个不同接口的类来进行通信**，在不修改这两个的前提下我们可能会需要某个**中间件**来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。

作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。

**何时使用：**

1. 系统需要使用现有的类，而此类的接口不符合系统的需要
1. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口
1. 通过接口转换，将一个类插入另一个类系中

**应用实例：**

1. 美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V
1. 在 Linux 运行 Windows 程序需要 Wine
1. Java 中的 jdbc

**优点：**

1. 可以让任何两个没有关联的类一起运行
1. 提高了类的复用
1. 增加了类的透明度
1. 灵活性好

**缺点：**

1. 过多地使用适配器，会让系统非常凌乱
1. 由于 Java 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类

## 桥接模式

如果说某个系统能够从多个角度来分类，且每一种分类都可能会变化，那么我们需要做的就是将这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合，这个分离的过程就用到了桥接模式。

**何时使用：**

1. 实现系统可能有多个角度分类，每一种角度都可能变化

**应用实例：**

1. 墙上的开关，可以看到的开关是抽象的，而不用管里面是怎么实现的

**优点：**

1. 抽象和实现的分离
1. 优秀的扩展能力
1. 实现细节对客户透明

**缺点：**

1. 桥接模式的引入会增加系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象层进行设计与编程

## 组合模式

组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。组合模式使得用户对单个对象和组合对象的使用具有一致性。

**何时使用：**

1. 想表示对象的部分-整体层次结构（树形结构）
1. 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象

**应用实例：**

1. 算术表达式包括操作数、操作符和另一个操作数，其中另一个操作符也可以是操作数、操作符和另一个操作数
1. 在 Java AWT 和 Swing 中，对于 Button 和 Checkbox 是树叶，Container 是树枝

**优点：**

1. 高层模块调用简单
1. 节点自由增加

**缺点：**

在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则

## 装饰器模式
## 外观模式
## 享元模式
## 代理模式
## 访问者模式
## 模板模式
## 策略模式
## 状态模式
## 观察者模式
## 备忘录模式
## 中介者模式
## 迭代器模式
## 解释器模式
## 命令模式
## 责任链模式

## 总结
